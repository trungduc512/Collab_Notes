worker_processes auto;
error_log /dev/stderr info;
events { worker_connections 1024; }

http {
    include mime.types;
    default_type application/json;

    lua_shared_dict jwt_cache 10m;
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";

    init_by_lua_block {
        jwt = require("resty.jwt")
        cjson = require("cjson")
    }
    # Use Docker embedded DNS; re-resolve every 5s
    resolver 127.0.0.11 valid=5s ipv6=off;

    upstream auth_service {
        server auth-service:5001;
    }

    upstream doc_service {
        server document-service:5002;
    }
   
    
    server {
        listen 80;
        set $ws_target ""  ;  # for websocket dynamic target

        #######################################################################
        # PUBLIC: LOGIN  (NO JWT)
        #######################################################################
        location /auth/login {

            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-User-Id, X-User-Name";
                add_header Access-Control-Allow-Methods "POST, OPTIONS";
                return 204;
            }

            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Credentials true always;

            proxy_pass http://auth_service/auth/login;
        }

        #######################################################################
        # PUBLIC: REGISTER (NO JWT)
        #######################################################################
        location /auth/register {

            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-User-Id, X-User-Name";
                add_header Access-Control-Allow-Methods "POST, OPTIONS";
                return 204;
            }

            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Credentials true always;

            proxy_pass http://auth_service/auth/register;
        }

        #######################################################################
        # PRIVATE: /auth/me (JWT)
        #######################################################################
        location /auth/me {

            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-User-Id, X-User-Name";
                add_header Access-Control-Allow-Methods "GET, OPTIONS";
                return 204;
            }

            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Credentials true always;

            # JWT VERIFY
            set_by_lua_block $jwt_user_id {
                local auth = ngx.req.get_headers()["Authorization"]
                if not auth then return "" end

                local token = auth:gsub("Bearer ", "")
                local jwt_obj = jwt:verify("hao123", token)

                if jwt_obj.verified then
                    return jwt_obj.payload.id
                else
                    ngx.status = 401
                    ngx.say(cjson.encode({ message = "Invalid JWT" }))
                    ngx.exit(401)
                end
            }

            proxy_set_header X-User-Id $jwt_user_id;
            proxy_set_header Authorization $http_authorization;
            proxy_set_header authorization $http_authorization;   # lowercase header fix for WS


            proxy_pass http://auth_service/auth/me;
        }

        #######################################################################
        # PRIVATE: DOCUMENTS
        #######################################################################
        location /documents {

            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-User-Id, X-User-Name";
                add_header Access-Control-Allow-Methods "GET, POST, PATCH, DELETE, OPTIONS";
                return 204;
            }

            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Credentials true always;

            # JWT VERIFY
            set_by_lua_block $jwt_user_id {
                local auth = ngx.req.get_headers()["Authorization"]
                if not auth then return "" end
                local token = auth:gsub("Bearer ", "")
                local jwt_obj = jwt:verify("hao123", token)
                if jwt_obj.verified then
                    return jwt_obj.payload.id
                else
                    ngx.status = 401
                    ngx.say(cjson.encode({ message = "Invalid JWT" }))
                    ngx.exit(401)
                end
            }

            proxy_set_header X-User-Id $jwt_user_id;
            proxy_set_header Authorization $http_authorization;
            proxy_set_header authorization $http_authorization;   # lowercase header fix for WS


            proxy_pass http://doc_service;
        }

        #######################################################################
        # PRIVATE: WEBSOCKET
        # WEBSOCKET: sticky routing by roomId
        # - resolve tasks.websocket-service via DNS
        # - pick IP by CRC32(roomId) % N
        # - proxy_pass directly to chosen IP:5003
        #######################################################################
        location /ws/socket.io/ {

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
         
            # CORS
            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Credentials true always;

            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-User-Id";
                add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
                return 204;
            }

            # JWT verify
            set_by_lua_block $jwt_user_id {
                local cookies = ngx.req.get_headers()["Cookie"] or ""
                local token = cookies:match("token=([^;]+)")
                ngx.log(ngx.ERR, "WebSocket - token from cookie: " .. (token or "nil"))
                if not token then return "" end
                local jwt_obj = jwt:verify("hao123", token)
                if jwt_obj.verified then
                ngx.log(ngx.ERR, "Gateway JWT verified for WS, userId: " .. jwt_obj.payload.id)
                    return jwt_obj.payload.id
                else
                ngx.log(ngx.ERR, "Invalid JWT")
                
                    return ""
                end
            }
            
            proxy_set_header X-User-Id $jwt_user_id;


           # Get roomId from query
            set_by_lua_block $room_id {
                local args = ngx.req.get_uri_args()
                ngx.log(ngx.ERR, "roomId: " .. (args["roomId"] or "nil"))
                return args["roomId"] or "default"
            }

            # Resolve WS peers dynamically
            access_by_lua_block {
                local resolver = require "resty.dns.resolver"
                local r = resolver:new{ nameservers={"127.0.0.11:53"}, timeout=2000 }
                local answers, err = r:query("tasks.websocket-service", {qtype=r.TYPE_A})
                if not answers then
                    ngx.log(ngx.ERR, "DNS query failed: ", err)
                    return ngx.exit(502)
                end
                local peers = {}
                for _, ans in ipairs(answers) do
                    if ans.address then table.insert(peers, ans.address) end
                end
                if #peers == 0 then
                    ngx.log(ngx.ERR, "No WS peers found")
                    return ngx.exit(502)
                end
                table.sort(peers)
                local crc32 = ngx.crc32_short
                local idx = (crc32(ngx.var.room_id) % #peers) + 1
                ngx.var.ws_target = peers[idx]
                ngx.log(ngx.ERR, "Chosen WS peer: ", peers[idx])
            }

            proxy_pass http://$ws_target:5003;
            proxy_connect_timeout 36s;
            proxy_read_timeout 3600s;
            proxy_send_timeout 10s;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        }
        #######################################################################
        # GLOBAL OPTIONS HANDLER  â€”  ALWAYS WORKS
        #######################################################################
        location / {
            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "http://localhost:5173";
                add_header Access-Control-Allow-Credentials true;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-User-Id, X-User-Name";
                add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS";
                return 204;
            }
            return 404;
        }
    }
}
